vue routing - vue-router

* npm install --save vue-router ile paketi yüklemeliyiz, 

* main.js de vue router ı import etmeliyiz, daha sonra bunu proje genelinde kullanamak için daha öncede kullnaadığımız gibi 
    Vue.use(VueRouter);
yapmalıyız, artık route yönlendirmelerimizi yapabiliriz

* rute tanımlamak için bir [{}, {}, {}] kullanırız, bunları main.js de de yapabiliriz ancak daha düzgün olması için routes.js adında bir dosya oluşturalım ve burada tutalım, 

* bu dosyadan export const routes = [{}, {}, {}] çıkacak, buradaki object lerin belli özellikleri olmalı, { path : '', component : Home }
bunun dediği hangi path (yol) gelirse hangi component çalışacak, boş bir yol gelirse Home component i çalışacak, bu arada bunun geçerli olmalı için önce Home comp un buraya import edilmesi gerekli,  

    export const routes = [
    { path : '', component : Home},
    { path : '/user', component : User}
]
bu routes.js i kullanabilmek için ayrıca bunun main.js e tanımlamamız lazım, şu anda main.js dosyamız;
    import Vue from 'vue'
import App from './App.vue'
import VueRouter from 'vue-router';
import { routes } from './routes'

Vue.use(VueRouter);

const router = new VueRouter({
  routes : routes
  //es6 da routes şeklinde tek yazarakda kullanabiliriz bunun anlamı routes : routes dir
  //bunu projemizde kullanabilmek için instance ımız içinde yani new Vue içinde de belirlememiz lazım
});

new Vue({
  el: '#app',
  router,
  //burada da aynı şey tek router , aynı şekilde router : router demek
  render: h => h(App)
})

bu şekilde, şu anda route çalışıyor ancak neden home gelmedi, bunun sebebi App.vue yani ana comp da home un nerede nasıl görüneceğini belirlemedik, App.vue şu anda boş duruyor, burada öncedeki gibi componentleri import et kendi elementlerinde kullan components { e ekle gibi şeylerle uğraşmadan} <router-view></router-view> ile içine herhangibir şey yazmadan çalışır hale gelsi, adres satırında bir şey olmadan home.vue geli,yor, /user yazdığımızada ise Userç.vue geliyor. Route yönetimi sorunsuz çalışıyor

* routing modları hash ve history, adres satırındaki # bize bir routing modu verir, adres dsatırında dizilim development ortamında anadomain/#routing mode / yönlenen sayfa
# olmadan da çalışabiliriz bunun için main.js de düzenleme yapmamaız lazım, açıklama main.js de

* router linkler ile comp arası gezinme, şimdiye kadar route lar arasında geçiş için / kullandık, gerçek hayatta bu şekilde olmaz şimdi gerçekte nasıl oluyor ona...
bunun için user folder içinde bir Header.vue oluşturalım, ve daha sonra bunu App.vue içinde router-view in üstünde kullanalım, bunun için tabiki önce import sonrada components içine tanımlamalıyız, bu tamamlandıktan sonra Header.vue ya geçeceğiz

* Header.vue da bizim korumamız gereken bir yapı var header kısmı hiyerarşi vs. bunu çözmemiz gerekiyor, <router-link></router-link> route lar arasında dolaşmamızı sağlamak vb. başka işlevleri olan bir element, 
aşağıdaki hale getireceğiz
    <ul class="nav nav-pills">
        <router-link 
            to="/"
            tag="li">
            <a>home</a>
        </router-link>
        <router-link
            to="/user"
            tag="li">
            <a>user</a>
        </router-link>

            <!-- <li><a href="">home</a></li>
            <li><a href="">user</a></li> -->
    </ul>

* burada küçük bir durum, nav elementleri üzerinde aktif olod. dair bir ifade yok, yani hangi sayfada old. adrs çubuğu ve/veya sayfadaki home / user ifadelerinden görüyoruz,

*neredeyiz, aktif olan linklere stil verme, elemente active-class="active" ve to sonrası exact dediğimizde to daki bütün path ı alır ve tam o path geldiğinde active olur,

* şu anda uygulamamızda kendi tıklamamızla sayfalara gidebiliyoruz ancak bir çok durumda uygulamada bir şeyler old. sonra sayfalara yönlenme gerekebilir (çok sık);  mesela user da bir buton olsun o buton bizi home a göndersin, 

* butonu yaptık ve @click="navigateToHome" yaptık, methods da da tanımlamasını yaptık, this.$router. ile router a ulaştık, router bir [] olduğu için bunun içine push yapabiliriz, push u 3 farklı şekilde kullanabiliriz, 
    //this.$router.push("/"); //home a gider, başarılı
    //this.$router.push({ path : '/'}); //bu da başarılı
    this.$router.push( { name : 'anasayfa'}); //bu da başarılı

*  route parametreleri; şu ana kadar static route yönetimi yaptık yani mesela diyelim user sayfasına gitmek istiyoruz ama özellikle user/10 a gitmek istiyoruz, routes.js üzerinde parametre tanımlamamız gerekli, mesela user path ini dinamik bir şeyler tanımlanabilir hale getireceğiz, 
    { path : '/user/:id', component : User , name : 'kullanici'}
burada user/10 olduğunda id 10 oluyor, gerekli düzenlemeyi header daki userdada yapacağız to="/user/10" dedik mesela artık user path ı değişti, 10 değilde adres satırına 15 yazsakta user sayfasına gideriz, 

* route parametrelerini okumak, kullanmak, User.vue da user ID: {{ id }} içeren bir p yapalım ve data oluşturalım, içinde id : this.$route.params.id dediğimizde route bilgisine .params.id ise parametrelerinden id yi al demek, 

* route parametrelerine göre component ile etkileşim, mesela headerda 2 tane user ımız var user 1 ve user 2 yaptık şimdi dikkat edersek user ID yi vren p deki ıd değeri user değişmesine rağmen değişmiyor bunun  sebebi User.vue comp u zaten cretae edildi, ve id ye atama yapıldı, bunu düzeltmemiz lazım, işte buna reactivity deniliyor, User.vue ya watch ekliyoruz, watch bir property yi izler bu prop un değeri değiştiğinde bir aksiyon alır, burada data daki id değişmiyor ancak route değişiyor, yani aksiyonu route un değişmesine göre alabiliriz, 
    watch: {
      // "$route"(value, oldValue){
      "$route"(to, from){
        this.id = to.params.id
      }
    },
böylelikle route daki değişiklikleri parametre olarak okuyabilir hale geldik, user Id bilgisi artık değişiyor, component tekrar render edilmeden

*  child routes (nested routes) 