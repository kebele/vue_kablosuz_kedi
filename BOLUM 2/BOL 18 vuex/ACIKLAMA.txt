vuex

* şimdiye kadar state yönetimi ile ilgili eçşitli yöntemleri yaptık, iki comp arasında veri iletişimi ile iligli mesela bilgi tazeleme olarak aynı seviyede comp larası veri akışının olamayacağı, (unidirectional veri akışı sadece yukarıdan aşağıyadır) bunu atlatabilmek için parenttan child a prop ile yolluyoruz, child dan parent a customEvent ile yolluyoruz, parentte artık child 1 de işlenmiş veriyi prop olarak child 3 e yolluyor, böylece C1 ile C3 arasında veri transferi yapmış oluyoruz, bunun dezavantajı eğer katman çoksa kontrol etmek çok zor, küçük uygulamalar için çok sıkıntılı değil ama orta ve büyük uygulamalar için çok sıkıntılı

* orta ölçek uygulamalar için eventBus yöntemi,  burada C1 den C3 e veri aktarmak için; c1 den veri $emit() ile eventBus a gidiyor, C3 ise bu veriyi $on() ile alıyor, bu durum yukarıya göre çok daha kolay ama bunun dejavantajı ise tek eventBus kulandığımızda eventBus çok çabuk kalabalıklaşır, bir diğer dezavantajı ise büyük uygulamalarda kulanmaya başladığımızda hamgi veri nerede $emit() lenmiş erede kullanılıyor, bunu takip etmek çok zor, debug süresi artmaya başlıyor vb.

* bu dejavantajları ortadan kaldırmak için kullanılan state management yöntemi vuex.

* vuex, redux ve flux ın bir implementasyonu, vuex in işi temelde state leri saklamak, state; data içinde sakladığımız her şeydir diyebiliriz, vuax bunlar app seviyesinde merkezi bir yerde saklıyor, buna store denir ( central store - state deposu ) 
senaryo; 1P, 3C, C1-c1, C2-c2 şeklinde,
bir veri transferi yapacaksak bu veri mutlaka central store da tutuluyor olmalı,
C1 den veri central store a gönderiliyor, C3 de bu veriyi get ile alıyor

* vuex yapılandırması ve store oluşturmak, kurs dosyalarını kurulum yapınca bir sayaç uygulaması var, counter.vue, result.vue, App.vue dan oluşuyor, vuex ile bu iş nasıl yapılıyor? 

* store klasörü yapacağız ve içine store.js yapıyoruz, vuex i uyg. dıraşıdan eklememiz lazım, 
    npm install --save vuex
store.js de vue ve vuex i import edeceğiz  vue nun içinde vuex kullanacğımızı belirteceğiz ve store u export edeceğiz
    import Vue from 'vue'
    import Vuex from 'vuex'

    Vue.use(Vuex);

    export const store = new Vuex.store({
        state : {
        counter : 0
        }
    });

* daha sonra main.js de store u import edeceğiz ve new Vue ya ekleyeceğiz

    import Vue from 'vue'
    import App from './App.vue'
    import { store } from './store/store'

    new Vue({
    el: '#app',
    store : store,
    render: h => h(App)
    })

* Counter.vue da methods u aşağıdaki gibi değiştiriyoruz
    methods : {
    incrementCounter(){
      // this.$emit("counterEvent", 1);
      this.$store.state.counter++;
    },
    decrementCounter(){
      // this.$emit("counterEvent", -1);
      this.$store.state.counter--;
    }
  }

* data sonra gösterme işlemi için Result.vue ya gidip aşağıdaki gibi düzenleyelim,
      export default {
            // props : ["counter"],
            computed : {
            counter(){
                return this.$store.state.counter;
                }
            }
        }

* state verilerine ulaşım yöntemi, mesela 2. bir sayaç yapalım result olarak, SecondResult.vue olsun, App.vue ya ekleyelim vs. yani iki tane sayacımız olsun, yalnız burada 2. sayaç için this.$store.state.counter *2 yapalım bu durumda 2 sayacımız olur ancak butonlarımız vs hepsi tek olduğu için sayaçlar aynı anda çalışır ve *2 şeklinde çalışırlar, bu durumda vuex kullanmanın mantığı kalmaz, böyle olmasını isteseydik eventBus ile de yapardık oysa vuex in mantığı farklı state lerin yönetimi, bu tür durumlar için getters kullanılıyor

* getters nedir nasıl çalışır, state içindeki verileri küçük tanımlamalarla birbirinden ayırıp istediğimiz yerden çağırabiliriz, mesela C1 den değişen veri store a yollanır, C3 te bu veriyi get ile store dan okur, getters bir katman gibi storedaki veriyi return ediyor ve bunun aracılığı ile C3 ün güncel veriye  erişmesini sağlıyor, şimdi SecondResult ta store a tanımladığımız veriyi getter a tanımlayacağız, store.js e gidip, state den farklı olarak getters adında bir property nesnesi oluşturacağız, 
export const store = new Vuex.Store({
    state : {
        counter : 0
    },
    getters : {
        getDoubleCounter(state){
            return state.counter * 2;
        }
    }
});

getter ı hazırladık daha sonra result.vue ve SecondResult.vue ya gidip return this.$store.getters.getDoubleCounter; şeklinde düzenlenir
      export default {
    // props : ["counter"],
    computed : {
      counter(){
        // return this.$store.state.counter * 2;
        return this.$store.getters.getDoubleCounter;
      }
    }
  }

* burada dikkat edeceğimiz şey comp içinden getter çağrılırken bu fuction notasyonuyla çağrılmaz, sadece ismi ile çağrılır, store.js de istediğimiz kadar çok, çeşitli getter tanımlayıp istediğimiz yerden açığrabiliriz. 

* mapGetters, mesela bir getter daha oluşturalım, store.js de daha sonrada SecondCounter.vue da bunun içinde düzenleme yapacağız, şu anda sıkıntı yok, 2 tane getter kullandık, 20 tane getter olsaydı 20 tane computed mi yapacaktık, bu noktada helper functions lar devre girecek , burada vuex den mapGetters componentini vuexden import edeceğiz, mapGetters bize store.js deki functionları getirir, mapgetters bir function ve parametre olarak ya [] ya da {} alır, burada computed ımız karşısındaki *2 getters ı yruma alalım ve koda bakalım, 
    mapGetters([
            'getDoubleCounter',
            'stringCounter'
        ])
peki ne durumda [] / {} olarak kullanılıyor, eğer getters ın ismi ile methodslarda bir function un ismi aynı ise bu durumda mapGetters {} şeklinde hazırlanır ve aynı isimdeki getter a bir key atanır template içinde de bu key ile kullanılır. 

* bir diğer nokta şu anda store içibdeki bütün getter ları mapGetters({}) ile getirebiliyoruz, peki store da olmayan  ama bu comp içinde kullanacağımız computed property ler varsa ne yapacağız, o zamanda spread kullanacağız, şu anda computed içinde nesne gibi duruyor, normal computed yapıyoruz, ve içine dummy bir (nasl kull. göstermek için) function yazalım, koda dikkat, mapGetters önüne 3 nokta... spread diyor ki mapGetters da tanımlanan fucioları al ve computed da sanki computed gibiymiş gibi kullan 

* mutataion nedir, nasıl çalışır? bir veriyi set ederken yani store da bulunan bir veriyi güncellerken yaşadığımız durum; biraz önceki örnekte store daki state e Counter.vue içinden müdahale ettik, artırdık veya azalttık, 
  this.$store.state.counter--;
bu şekilde, bu noktada 3 -5 tane olsa ok ama yüzlerce müdahale edeceğimi< state yada durum olursa bize bir yapı lazım, verileri set ederken yani store daki bir verinin durmunu güncellerken kullandığımız bir ara katman var bunun adı mutations, yaptığı iş; C1 altındaki bir comptam store içindeki bir state in değerini değiştirmek istersek commit kullanırız, commt ile değer değiştirme functionuu çağırırız o da stroe a gider ilgili state i günceller, 

* mutataions da store.js içinde tanımlanır, 

