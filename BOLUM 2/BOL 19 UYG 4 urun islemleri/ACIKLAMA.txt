genel tekrar projesi

* ürün işlemleri, ürün girişi, çıkışı, alış satış tutarları bakiye vs. firebase üzerinde tutatacağız, firebase restApi kullanacağız

* App.vue yu temizledik, temiz bir sayfa hazırladık, src>components>products + shared klasörlerini hazırladık, shared>Header.vue + Footer.vue hazırladık, Products>ProductList.vue + ProductSell.vue + ProductPurchase.vue hazırladık,

* index.html ye bootstrap ı koyalım ve Header.vue ve Footer.vue ile başlayalım, template deki header ve footer alanlarını kopyalayıp bunlara koyduk, ProductPurchase.vue ya da container ı koyduk, şimdi App.vue ya importları yapalım ve sayfayı basalım, template deki sayfalardaki container ları vue dosyalarımıza taşıdık ve App.vue da değişiklikler ile denemelerini yaptık

* vue router projeye ekleyelim, npm install vue-router --save ile projeye ekledik, npm run dev diyerek uyg yeniden çalıştırdık, ve src> router.js oluşturduk ve vue-router ı import ettik, 
    import VueRouter from 'vue-router'
routes = [] oluşturyoruz, içinde yollarımız olacak, her bir route/yol/url için ayrı nesneler olacak, 
burada hangi istek gelirse hangi path ve/veya hangi component çalışacak, mesela
    { path : "/", component : ProductList }
anasayfa isteği gelirse ProductList çalışacak, ProductSell, ProductPurchase içinde path leri hazırladık, * (ne gelirse gelsin bunların dışında "/" ana sayfaya redirect te yaptık), önceden main js de kullandığımız bazı durumları buradan hazırladık, new VueRouter ve Vue.use(VueRouter gibi), şimdi main.js e gidip bunu import edelim, ve new Vue içine router i ekledik, artık App.vue da denememizi yapalım, app-container ımızı vardı bunun yerine router-view kullanacağız, denemelerde sıkıntısız çalışıyor, path leri adres çubuğundna yazdık, çalışıyor, 

* router-link navigasyon ayarları, yani nav daki tıklamalarla sayfalara gitmesi, Header.vue ya gidip router-link ler le hazırlamaya başlayalım, link ler aşağıdaki şekilde oluşturulacak
    <router-link
                active-class="active" 
                to="/urun-islemleri"
                tag="li"
                class="nav-item">
                    <a class="nav-link">Ürün İşlemleri</a>
            </router-link>

*vuex eklenmesi ve product modulu hazırlanması, npm install vuex --save sonrası npm run dev ile yeniden çalıştır, vuex yapılandıralım, ürülere ilişkin bir çok işlem olacak, ürün girişi, çıkışı, firebase üzrinden getirilmesi,  alış, satış tutarları, bakiye kısımları, bunlar comp larla ilgili değil, merkezi bir yerde toplanmalı, 

* src>store>modules>product.js yaptık, içinde bir state sabiti (const) bir nesne oluşturuyoruz, sonra bir getters nesnesi, sonra mutations ve actions nesnelerini oluşturduk, ve bunların hepsini export etmliyiz ki başka yerlerden kullanabilelim, şimdi state içinde neleri tutacağımızı belirleyelim, products : [] ürün listesiiçindeki şeyler burada duracak, burada bunları db dende alabilirdik ama perf ve maliyetle karşılaşırdık, getters içinde getProducts(state){} olsun ürünleri getiremizi sağlasın, burada state içimnden ürün getireceğimiz için state bunun parametresi olacak ve return state.products dönecek bu liste ile ilgili olan yani bütün ürünlerle ilgili birde bize tek bir ürün için getter lazım, getProduct(state){} bunuda hazırlayalım, sırada mutations var, burada mutataions burada sadece update, yani products : [] ı güncellemek, 
    updateProductList(state, product){
        state.products.push(product);
    }
actions, mutations ın gürevi state i güncellemek (set işlemleri) sync çalışır anında yani, actions ise mutation a async özelliği eklenmiş hali, mesela actions ile dış servise bağlanıyoruz dönen cevaba göre mutation çalışıyor, o da state i güncelliyor, bizim burada uyg. dışa bağımlı old. için bolca actions lazım, koda bak 

* store> store.js hazırladık, bütün modülleri store içinde tanımlıyoruz, sonrada gidip bu store u main.js e ekliyoruz, import ve new Vue ya

* alış, satış ve bakiye için store un düzenlenmesi, store.js de state in içine purchase, sale, balance bilgilerini hazırladık ve hepsini 0.0 verdik, birde modules imiz vardı, şimdi getters, mutations falan buraya tanımlarsak burası şişer o yüzden bunların hepsini eğitimde ayrı js lerde toplamıştık, onları hazırlayalım, 

* store>getters.js , actions.js ve mutations.js oluştuaracğız, getters.js ile başlayalım, bize getter olarak lazım olan şey state de belirlediğimiz 3 tane değeri bize geri döndürecek bir func lazım, parametre olarak state i almalı ki içine girebilsin ve bize döndürdüğü bir nesne olsun ki 3 state i de ayrı ayrı görebilelim, kodu hazırladık, sırada mutations.js var, burada da bir func oluşturuyoruz state i update etmesi için state, payload parametreleri olacak state belli payload ise update edeceği değerler, yani payload u dışarıdan alacak, yani dışarıdan gelen payload ile state deki purchase, sale ve balance update edeceğiz

* actions.js, biz burada state imizdeki purchase ve sale i firebase e göndreceğiz ve oradan alacağız bunun için gerekli olan func. tanımlayalım 
setTradeResult({state}) =>{...}
firebase e gönderecek
getTradeResult = ({}) => {...}
firebase den getirecek

* artık bunları store.js den çağıralım, import ile yapacağız
    import * as getters from './getters'
bunun anlamı getters içindekileri getters ismi ile bir object olarak getir, 
    ve bunu store a ekleyeceğiz, 
aynı şeyleri mutations ve actions içinde yapacağız, böylece uygulama içindeki verilerinde storedaki tanımlarını yaptık, 

* firebase de uygulama oluşturmak,
console.firebase.com dan proje oluşturyoruz, projemize eklemek için geekli kodları kopyalıyoruz, projemizde firebase den sadece db yi kullanacağız, onda da real-time db yi kullanacağız, oluştur deyip test modunda başlayacağız, sebebi kilitliyi seçersek authenticaton falan uğraşmamaız lazım, 

* birde firebase de kullanacağımız firebase restApi kullanacağız, 
https://firebase.google.com/docs/reference/rest/database, bunu kullanacğız, artık projede kullanabilmemiz için firebase tarafoındaki yapılanduırma tamam bunu projemizde kullanabilmemiz için vue-resource u projemize eklememiz lazım, 
npm install vue-resource --save
yükleme sonrası npm run dev ile projeyi yeniden başlatalım, şimdi main.js de vue resource u import yapacağız ve 
Vue.use(VueResource)
diyeceğiz, 

* ürünün firebase üzerine kayıt edilmesi, urun islmeleri sayfasında ürünün adı, adet, fiyat açıklama vs girdikten sonra kaydet dediğimizde firebase e kaydedecek, brada önemli bir şey eğer eksiklik varsa kaydet pasif kalacak, bir başkası kaydete basınca bir loading geliyor ekrana, ayrıca alt taraftaki tutarlar bakiye vs de güncelleniyor. 

* temelle başlayalım, temelde ürün işlemlerinde yapılan iş, ürünün adı, adedi, fiyatı ve açıklamasını alıp firebase e kaydedecek, ihtiyacımız olan dosyalar, 
    store > modules > produt.js --> getters, setters, mutations, actions burada, 
    components > products > ProductPurchase.vue --> ürün işlemleri burada
bunları açıp işlemlere başlayacağız,  ProductPurchase.vue da script e kodları yazalım, yapacağımız iey inputtaki verileri almak, data(){ return { ... }} içine product{...} tanımlayacağız sonuçta bu inputların her biri product ile alakalı, 
    product : {
                title : "",
                count :  null, 
                price : null, 
                description : ""
            }
    şimdi v-model ile bunları template de ilgili elementlere bağlayalım,  v-model="product.title, bir konuda fiyat ve adet in tipi number yapalım, 

* şimdi kaydet butonu, burada buton firebase e bağlanacak ve inputtan gelen verileri firebase e kaydedecek yani ortada async bir işlem var, db dışarıda old. için, bu durumda bunun düzenlemesini actions da yapacağız, product.js e gideceğiz, prduct.js e önce vue yu import edelim, import sonrası actions içindeki saveProduct(){...} ı düzenleyeceğiz,
    Vue.http.post("", product)
    bununla http ye ulaşıp bir post işlemi yapacağız, ilk parametre url adresi ikincisi ise bu url ye göndereceğimiz şey, burada payload object ini göndereceğiz, url yi firebase in bize verdiği kodlardan alacağız, url ye /products.json ekliyoruz, firebase json olarak tutuyor dosyaları, firebase den bize bir cevap gelecek .then() ile ...
        Vue.http.post("https://urun-islemleri-59b86.firebaseio.com/products.json", product)
            .then((response) => {
                console.log(response)
            })
    bunu denememiz için bizim bir payload yollamamız lazım, ProductPurchase.vue ya gidip, bu payload a gelecek olan product nesnemizi yolayalım, butonu bir saveProduct diye func. tanımlayalım, 
    this.$store.dispatch("saveProduct", this.product) $ store ile store a yolluyoruyz, dispatch ise bizim yapacağımız işlem actions old. için saveProduct ı çalıştır dedik, peki buraya veri gönderememiz lazım buda this.product, yani data oluşturduğumuz product nesnesi, denemsini yapalım, sayfayı doluralım ve kaydete basalım, console gelen bilgilier ok, firebase e bakalım, product isimli nesneyi oluşturmuş, içinede bilgilieri yazmış, işlem başarılı, 

* bu işlemi actionMapp ile de yapabilirdik ancak bu şekilde yaptık, sebebi her kayıt sonrası loading çıkması istiyoruz, onun için bize ayrı ayı lazım, bu fuciton un çalışması, şimdi ürün listesinin güncellenmesi var, firebase e ürün yolladık, şimdi ürün listesi listeyi firebase den çekecek, mutations içinde updateProductList(){} var, bunun yaptığı şey eklenen ürünü products = [] a push luyor, firebase den veri aldığımızda bize id/name i kendisi veriyor,  response.body.name içinde, o key i de alıp product içine koyabiliriz, saveProduct içinde onuda save leyelim, 

saveProduct({ commit, state }, product){
        // vue resource işlemleri ...
        Vue.http.post("https://urun-islemleri-59b86.firebaseio.com/products.json", product)
            .then((response) => {
                product.key = response.body.name
                commit("updateProductList", product)
                // console.log(response)
                console.log(state.products)
            })
    },
denemyi yaptığımızda ürün ekledikçe products ı güncelliyor, ve yeni eklediklerimizi pushuyor, key lerde de sıkıntı yok, firebase dende kontrol ok, 

* alt taraftaki alış, satış balance ı yapalım, store.js de vue, vuex, getirdik, modules den product ı getirdik, ürüne ilişkin işlemler, state, getters, mutations, actions burada, ve buradan state, getters, mutations, actions export ediyoruz,  ayrıuca store..js de 
    Vue.use(Vuex)
diyoruz, yani vuex kullanacağım, burada da bir state var, içinde purchase, sale, balance var, getters, mutations, actions, modules >  product  bunları da export ediyoruz, 
şimdi bizim bu 3 değeri set etmemiz lazım, set deyince akla mutations gelir, mutations.js e gidelim, updateTradeResult(){} var burada, ayrıca bizim asıl kaydedecğimiz yer firebase o zamanda actions akla gelir actions.js ye bakalım,  orada da setTradeResult (){} var, önce mutations da setTradeResult işlemi yapalım, daha sonra da http yardımı ile actions olarak firebase i güncelleyelim, product.js ye gidelim,  saveProduct a dispatch tanımlayalım ve .then içine dispatch koyalım, dispatch actions u akla getirir, dispatch e setTradeResult ı dispatch edecek firebase e, şimdi neyi dispatch edecek, tradeResult ı tradeResult adında bir nesne tanımlayacağız, içinde purchase, sale ve count tutacak, count product.count dan gelecek, purchase ve sale ise işlemin satış yada alış old. belirlemekte kullnaılacak, şimdi actions. da setTradeResult a gideceğiz, burada bizim payload olarak tradeResult a ihtiyacımız var, burada önce store daki state imizi (purchase, sale, balance) ı güncelleyeceğiz, bunu mutations.js deki updateTradeResult ile, parametre olarak commit ekleyeceğiz, commit mutations u akla getiri zaten, 
    commit("updateTradeResult", tradeResult)
yani burada dediğimiz updateTradeResult a tradeResult ı commit le, böylelikle mutations a gönderdik şimdi mutatins a gideceğiz, 
state deki purchase ı state.sale i burada update edeceğiz += e dikkat, burada state.purchase, state.sale ve state.balance ı hazırladık, actions a geri dönüp artık firebase kısmını yapacağız, bunun için Vue.http.put() kullanacağız, bundna önce ise vue importunu yapacağız, burada put kullanamaıızım sebebi put bir kayıt ekler sonrakinden o eklediğinin üzerine yazar, post ise sürekli yeni kayıt ekler, üzerine yazmaz, buradaki dosyamızın adı ise trade-result olsun, nereye kaydedeceğiz hazır peki neyi kaydedecek ? , tradeData bunun için tradeData nesnesi tanımlayacağız içinde de state.purchase ve state.sale olacak, şimdi önce product.js deki dispatch çalışacak sonra mutations sonrada actions çalışacak, actions da ilgili kısımları
    let tradeData = {
        purchase : state.purchase,
        sale : state.sale
    }
    Vue.http.put("https://urun-islemleri-59b86.firebaseio.com/trade-result.json", )
        .then((response) => {
            console.log(response)
        })
lattarata 34xx falan yazıyor sonra yapacapız, 
* xxxxx

* footer üzerindeki verilerin güncellenmesi, bunu footer.vue içinde göstereceğiz, getters.js de bu bilgileri getTradeResult içinde bu bilgiler var, bunun görevi verileri getirmek, getters ları computed ile gösterebiliyoruz, computed ın görevi değişince ekrana basmak, 
    Footer.vue da vuex importu sonrası
    computed : mapGetters(["getTradeResult"])
daha sonra template içinde {{ getTradeResult.purchase }} gibisinden verilieri alıp ilgili elemente basarız

* sayfayı yenilediğimizde firebase den alış satışı alsın, bu işlemde async old. için actions, içine gidelim, getTradeResult var, Vue.http.get("https://urun-islemleri-59b86.firebaseio.com/trade-result.json") ikinci parametre yok, çünkü zaten bulunan bir veriyi getiremek istiyoruz, 
    export const getTradeResult = ({ commit }) => {
    // firebase bağlanacak ve oradaki verileri alıp state i güncelleyeceğiz, state i güncelleyen şey mutations, o zaman şu anda actions dayız mutations ı buradan çağırmalıyız, bunun için bu func. commit i parametre olarak alacağız
    Vue.http.get("https://urun-islemleri-59b86.firebaseio.com/trade-result.json")
        .then((response) => {
            console.log(response)
        })
}

biz bu getTradeResult ı nerede kullanmalıyız, uyg App.vue da çalışıyor, o zaman bu comp create old. bu aksiyon çalışsın, life cycle lardan create kullanacağız, yani bu App.vue create edildiğinden çalışacak, this.$store.dispatch('getTradeResult) yani sayfa create edildi, store a git oradaki getTradeResult ı dispatch le dispatch old. için actions a gidecek orada getTradeResult u çalışıracak, veriyi çektik, bu veri ile store u güncelleyeceğiz, güncelleme mutations çğrıştırır, o zaman mutations.js e gideceğiz, biz buna purchase, sale vecount u gönderdiğimizde burası set eder ama count u firebase de tutmuyoruz,o zaman mutations ı biraz modifiye edeceğiz, eğer payload da bir count varsa countlu ifadelerini kullan yoksa cont ile çarpılmamış ifadeleri kullan, burası tamam actions a geri döneceğiz, getTradeResult dan commit ile mutations daki updateTradeResult ı çağıralım ve buna  response.body yi yollayalım, 

* tutar ve bakiyenin filter ile daha güzel görünmesi, bu para formatında görünsün, filter ı footer.vue içindede tanımlayabiiriz, o comp ta kullanırız veya global olarak main.js de tanımlayabiliriz, global yapalım, filter bir func. içine value yollayacağız o bize istediğimiz şekilde bu value yu gözterecek, kullanımı {{ purchase | currencey }} şeklinde, Footer.vue ya gidelim ve template deki ilgili yerlerde kullanalım, 

* kaydet butonunun verilere göre aktif/pasif olması, 